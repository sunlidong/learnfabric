在本文中，你将学习如何将ETH从一个帐户转移到另一个帐户。如果你已经熟悉以太坊，那么你就知道交易包括你发送的以太币量，gas限额，gas价格，随机数，接收地址以及可选数据。在将他被广播到网络之前，必须使用发送方的私钥对该交易进行签名。

假设你已经连接了客户端，下一步就是加载你的私钥。

privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
if err != nil {
  log.Fatal(err)
}
之后我们需要获得帐户nonce。每笔交易都需要一个nonce。根据定义，nonce是仅使用一次的数字。如果是发送交易的新帐户，则nonce将为0。来自帐户的每个新交易必须具有前一个nonce增加1的nonce。很难保持所有nonce的手动跟踪，以便ethereum客户端提供辅助方法PendingNonceAt将返回你应该使用的下一个nonce。

该函数需要我们发送的帐户的公共地址，我们可以从私钥中获取该帐户。

publicKey := privateKey.Public()
publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
if !ok {
  log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
}

fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
这里，privateKey.Public()返回包含我们的公钥的接口。我们使用publicKey。(<expectedType>)执行类型断言，以明确设置publicKey变量的类型，并将其分配给publicKeyECDSA。这允许我们在程序期望输入*ecdsa.PublicKey类型的地方使用它。

现在我们可以读取我们应该用于帐户交易的随机数。

nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
if err != nil {
  log.Fatal(err)
}
下一步是设置我们将要转移的ETH数量。但是我们必须将以太网转换为wei，因为这是以太坊区块链使用的。以太网支持最多18个小数位，因此1个ETH为1加18个零。这里有一个小工具可以帮助你在ETH和wei之间进行转换：https://etherconverter.online

value := big.NewInt(1000000000000000000) // in wei (1 eth)
标准ETH转移的gas限制为21000单位。

gasLimit := uint64(21000) // in units
gas价格必须在wei中设定。在撰写本文时，将在一个区块中包含相当快的交易的gas价格为30gwei。

gasPrice := big.NewInt(30000000000) // in wei (30 gwei)
然而，gas价格总是根据市场需求和用户愿意支付的价格而波动，因此对gas价格进行硬编码有时并不理想。go-ethereum客户提供SuggestGasPrice函数，用于根据先前块的x个数来获取平均gas价格。

gasPrice, err := client.SuggestGasPrice(context.Background())
if err != nil {
  log.Fatal(err)
}
我们弄清楚我们将ETH发送给谁。

toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")
现在我们可以通过导入go-ethereum core/types包并调用NewTransaction来生成我们的无符号以太坊交易，NewTransaction接收nonce，地址，价值，gas限价，gas价格和可选数据。仅发送ETH的数据字段为零。在与智能合约进行交互时，我们将使用数据字段。

tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, nil)
下一步是使用发件人的私钥对交易进行签名。为此，我们调用SignTx方法，该方法接受无符号交易和我们之前构造的私钥。SignTx方法需要EIP155签名者，我们从客户端派生链ID。

chainID, err := client.NetworkID(context.Background())
if err != nil {
  log.Fatal(err)
}

signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
if err != nil {
  log.Fatal(err)
}
现在，我们终于准备通过调用接收已签名交易的客户端上的SendTransaction将交易广播到整个网络。

err = client.SendTransaction(context.Background(), signedTx)
if err != nil {
  log.Fatal(err)
}

fmt.Printf("tx sent: %s", signedTx.Hash().Hex()) // tx sent: 0x77006fcb3938f648e2cc65bafd27dec30b9bfbe9df41f78498b9c8b7322a249e
之后，你可以检查块浏览器上的进度，例如https://rinkeby.etherscan.io/tx/0x77006fcb3938f648e2cc65bafd27dec30b9bfbe9df41f78498b9c8b7322a249e

Full code
transfer_eth.go

package main

import (
    "context"
    "crypto/ecdsa"
    "fmt"
    "log"
    "math/big"

    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/core/types"
    "github.com/ethereum/go-ethereum/crypto"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    client, err := ethclient.Dial("https://rinkeby.infura.io")
    if err != nil {
        log.Fatal(err)
    }

    privateKey, err := crypto.HexToECDSA("fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19")
    if err != nil {
        log.Fatal(err)
    }

    publicKey := privateKey.Public()
    publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
    if !ok {
        log.Fatal("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
    }

    fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
    nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
    if err != nil {
        log.Fatal(err)
    }

    value := big.NewInt(1000000000000000000) // in wei (1 eth)
    gasLimit := uint64(21000)                // in units
    gasPrice, err := client.SuggestGasPrice(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    toAddress := common.HexToAddress("0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d")
    var data []byte
    tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, data)

    chainID, err := client.NetworkID(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
    if err != nil {
        log.Fatal(err)
    }

    err = client.SendTransaction(context.Background(), signedTx)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("tx sent: %s", signedTx.Hash().Hex())
}
